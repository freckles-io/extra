#! /usr/bin/env bash
#
# ============================================================
#
# Script to manage a git repository containing Ansible roles
#
# =============================================================
# Helper functions

function command_exists {
    type "$1" > /dev/null 2>&1 ;
}

function error_exit {

    #	----------------------------------------------------------------
    #	Function for exit due to fatal program error
    #		Accepts 1 argument:
    #			string containing descriptive error message
    #	----------------------------------------------------------------

	  error_output "${PROGNAME}: ${1:-"Unknown Error"}" 1>&2
	  exit 1
}

function error_output() {
    # log $1
    (>&2 echo "$@")
}

# =============================================================
# COMMANDS

function command_pull_upstream {

   while getopts ":h" opt; do
     case ${opt} in
     h )
      echo "Usage:"
      echo "    repo-manage pull-upstream -h              display this help message."
      echo "    repo-manage pull-upstream ROLE_NAME       adds a remote repo."
      exit 0
      ;;
     \? )
       echo "Invalid Option: -$OPTARG" 1>&2
       exit 1
       ;;
     : )
       echo "Invalid Option: -$OPTARG requires an argument" 1>&2
       exit 1
       ;;
     esac
   done

   shift $((OPTIND -1))

   if [[ "$#" -ne 1 ]]; then
      echo ""
      echo "Illegal number of arguments: exactly one REPO_URL allowed."
      echo ""
      exit 1
   fi

   role_name="$1"
   echo "$role_name"


}

function command_add {
   fork=false
   while getopts ":hfp:" opt; do
     case ${opt} in
     h )
      echo "Usage:"
      echo "    repo-manage add -h                                display this help message."
      echo "    repo-manage add [-f] -p LOCAL_PATH REPO_URL       adds a remote repo."
      exit 0
      ;;
     f )
       fork=true
       ;;
     p )
       local_path=$OPTARG
       ;;
     \? )
       echo "Invalid Option: -$OPTARG" 1>&2
       exit 1
       ;;
     : )
       echo "Invalid Option: -$OPTARG requires an argument" 1>&2
       exit 1
       ;;
     esac
   done

   shift $((OPTIND -1))

   if [[ -z "$local_path" ]]; then
      echo ""
      echo "No local path provided, please use '-p' option"
      echo ""
      exit 1
   else
      if [[ -e ${local_path} ]]; then
        echo ""
        echo "Path '${local_path}' already exists"
        echo ""
        exit 1
      fi
   fi

   if [[ "$#" -ne 1 ]]; then
      echo ""
      echo "Illegal number of arguments: exactly one REPO_URL allowed."
      echo ""
      exit 1
   fi

   repo_url="$1"
   echo "$repo_url"
   role_name="$(basename $local_path)"

   if [ "${fork}" = true ]; then
      echo "forking repo not supported yet."
      exit 2
      # forking the repo
      upstream_repo_username="geerlingguy"
      upstream_repo_name="ansible-role-docker"

      echo "Forking repo"
      curl -u "$GITHUB_USERNAME:$GITHUB_TOKEN" "https://api.github.com/repos/$upstream_repo_username/$upstream_repo_name/forks" -d ''

   fi

   upstream_alias="${role_name}_upstream"

   # adding alias
   git remote add -f ${upstream_alias} ${repo_url} || error_exit "Could not add remote '${repo_url}'"
   # adding repo
   git subtree add --prefix ${local_path} ${upstream_alias} master --squash || error_exit "Could not add remote tree '${repo_url}' to: ${local_path}"

   echo "Added repositury '${repo_url}' (using alias '${upstream_alias}' at path: ${local_path}"
   echo "${role_name}=${local_path}" >> .role_repos

}



# =============================================================
# VARS

PROGNAME="repo-manage"
GITHUB_ACCOUNT=freckles-io

GITHUB_USERNAME=`git config github.user`
if [ "$GITHUB_USERNAME" = "" ]; then
  echo ""
  echo "Could not find username, run 'git config --global github.user <username>'"
  echo ""
  exit 1
fi

if command_exists secret-tool; then
   GITHUB_TOKEN=`secret-tool lookup server api.github.com user "$GITHUB_USERNAME" key password`
   if [[ -z "$GITHUB_TOKEN" ]]; then
      echo ""
      echo "No github token found in keyring, please create one with access to repo functions ( https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/ ), then store it via:

  secret-tool store --label='github_token' server api.github.com user "$GITHUB_USERNAME" key password"
      echo ""
      exit 1
   fi

else
  echo ""
  echo "Could not find 'secret-tool' executable, please install (e.g. 'apt install libsecret-tools')"
  echo ""
  exit 1
fi

# =============================================================
# ARG PARSING

subcommand=$1
shift


case "$subcommand" in
  add)
    command_add "$@"
    ;;
  pull-upstream)
    command_pull_upstream "$@"
    ;;
esac

#eval "command_$subcommand $repo_url"
